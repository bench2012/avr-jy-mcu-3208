#!/usr/bin/python

import sys
from configparser import ConfigParser
from optparse import OptionParser
from PIL import Image


def char_or_number_to_int(s):
    s = s.strip()
    if len(s) == 3 and s[0] == '\'' and s[2] == '\'':
        return ord(s[1])
    return int(s, 0)


def parse_char_range(s):
    # return an array of numbers according to given
    # string s which may consist of single numbers,
    # characters and ranges thereof, e.g. "0x20,17,'a'-'z',9-13"
    ret = list()
    for elm in s.split(','):
        arr2 = list(map(char_or_number_to_int, elm.split('-')))
        if len(arr2) == 1:
            ret.append(arr2[0])
            continue
        if len(arr2) == 2:
            ret = ret+list(range(arr2[0], arr2[1]+1))
            continue
        raise RuntimeError('Cannot parse %s in %s.' % (elm, s))
    return ret


P = OptionParser(usage='%prog [options] cfgfile pngfile')
opts, args = P.parse_args()

CP = ConfigParser()
CP.read(args[0])

IMG = Image.open(args[1]).convert('RGB')

width = CP.getint('font', 'width')
height = CP.getint('font', 'height')
img_offs_x = CP.getint('font', 'img_offs_x')
img_offs_y = CP.getint('font', 'img_offs_y')
img_skip_x = CP.getint('font', 'img_skip_x')
img_skip_y = CP.getint('font', 'img_skip_y')
cells_per_row = CP.getint('font', 'cells_per_row')
symbol_name = CP.get('font', 'symbol_name')

pixel_data_arr = list()
character_offset_arr = list()

print('Image %s has size %d,%d.' %
      (args[1], IMG.size[0], IMG.size[1]), file=sys.stderr)

for i, c in enumerate(parse_char_range(CP.get('font', 'chars'))):
    col = i % cells_per_row
    row = i // cells_per_row
#	print >>sys.stderr,'  #%d: Getting character 0x%02x from image at %d/%d.'%(i,c,col,row)

    character_offset_arr.append((c, len(pixel_data_arr)))
    for xoffs in range(width):
        x = xoffs + img_offs_x + col * (width+img_skip_x)
        word = 0
        for yoffs in range(height):
            y = yoffs + img_offs_y + row * (height+img_skip_y)
            px = IMG.getpixel((x, y))

            word = word << 1
            if px[0] > 200 or px[1] > 200 or px[2] > 200:
                word = word | 0x1

        pixel_data_arr.append(word)

character_offset_arr.append((0xff, 0xffff))


def bitpattern(val):
    bit = 0x01
    ret = ''
    while (bit & 0xff) != 0:
        if val & bit:
            ret = ret + '*'
        else:
            ret = ret + ' '
        bit = bit << 1
    return ret


print('/* Autogenerated, do not edit. */')
print('#include "fonts.h"')


print('static const PROGMEM uint8_t %s_data[]={' % (symbol_name))
print('\t'+',\n\t'.join(['0x%02x /* %s */' %
                         (v, bitpattern(v)) for v in pixel_data_arr]))
print('};')

print('static const PROGMEM struct font_offset %s_offs[]={' % (symbol_name))
print('\t'+',\n\t'.join(['{ .code=0x%02x, .offs=0x%04x }' %
                         pair for pair in character_offset_arr]))
print('};')

print('const PROGMEM struct font_info %s_info={' % (symbol_name))
print('   .width = %d,' % (width))
print('   .height = %d,' % (height))
print('   .data = %s_data,' % (symbol_name))
print('   .offs = %s_offs,' % (symbol_name))
print('   .nchars = %d' % (len(character_offset_arr)))
print('};')
